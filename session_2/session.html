<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Session</title>
  <script>
    window.onload = () => {





      // Plan

      // Main topic: JavaScript.

      // feedback from previous session
      // logical operators
      // optional chaining operator
      // spread operator
      // object destructuring
      // async vs sync
      // Promise
      // callback





















      // Feedback









      // I would like to thank all of you
      // who sent me your feedback.
      // It is super valuable for me.












      // 1) github link. I have provided in the chat

      // 2) more examples











      // Going forward I will try to show
      // you examples of what we learn
      // in our CCL2 application















      // Demo how to follow lecture files





      // Logical Operators













      // && (AND)
      // || (OR)








      // Surprisingly, but these operators
      // may be used not only inside of if conditions.











      // && (AND)






      // This operator evaluates the expression
      // and returns:
      // -- value of first falsy operand
      // -- value of the last operand if all are truthy





      // operands:

      // Example:
      // A && B

      // Here operands are A and B







      // console.log("" && true); // output is empty string, not false, even if empty string is falsy
      // console.log(0 && true); // 0
      // console.log(1 < 2 && null); // null
      // console.log(1 < 2 && undefined && false); // undefined
      // console.log(1 && 2); // 2
      // console.log(1 && 2 && 3 && 4 && -1); // -1
      // console.log(1 < 2 && 'hi'); // 'hi'




      // Short circuit.

      // Important!
      // && = will NEVER execute right-hand side
      // if left-hand side is false

      // console.log(false && 'you never see me');

      // This feature allows me to write code like:

      // const isLoggedIn = true;
      // isLoggedIn && console.log('You are logged in');



      // CCL2 Example:
      // https://githubifc.iad.ca.inet/ContactCL/cbfq-rg-appstatic/blob/221f0651562dbd69730c14803696e3fa65b7dffe/projects/cbfq-appstatic/src/app/modules/navigation/services/navigation.service.ts#L215











      // || (OR)






      // This operator evaluates the expression
      // and returns:
      // -- value of first truthy operand
      // -- value of the last operand if all are falsy


      // console.log(1 || 2); // 1
      // console.log(3 || true || []); // 3
      // console.log(null || 'city'); // city
      // console.log(false || 0 || '' || undefined); // undefined



      // Short circuit.

      // Important!
      // || = will NEVER execute right-hand side
      // if left-hand side is true

      // console.log(true || 'you never see me');


      // Important!
      // On the other hand
      // || = will ALWAYS execute right-hand side
      // if left-hand side is false

      // console.log(false || 'you always see me');


      // This feature allows me to set default values like:

      // const username = null;
      // const name = username || "Default value: Guest";
      // console.log(name);




      // CCL2 Examples:

      // https://githubifc.iad.ca.inet/ContactCL/cbfq-rg-appstatic/blob/221f0651562dbd69730c14803696e3fa65b7dffe/projects/cbfq-appstatic/src/app/modules/offer/services/offer.service.ts#L449
      // https://githubifc.iad.ca.inet/ContactCL/cbfq-rg-appstatic/blob/221f0651562dbd69730c14803696e3fa65b7dffe/projects/cbfq-appstatic/src/app/modules/add-coverage/components/add-coverages-dialog/add-coverages-dialog.component.ts#L370











      // ?? (Nullish Coalescing)









      // It is similar to || (OR) with one exception:
      // it checks for null or undefined only
      // while || checks for any falsy value.










      // Example

      // const name = null;
      // const defaultName = "Guest";
      // const result = name ?? defaultName;
      // console.log(result); // Guest




      // Difference between ?? and ||

      // const count = 0;
      // const result1 = count || 10;
      // const result2 = count ?? 10;
      // console.log(result1); // 10
      // console.log(result2); // 0



      // CCL2 Example:
      // https://githubifc.iad.ca.inet/ContactCL/cbfq-rg-appstatic/blob/221f0651562dbd69730c14803696e3fa65b7dffe/projects/cbfq-appstatic/src/app/modules/bind/services/bind.service.ts#L123
















      // Optional chaining operator (?.)












      // Allows reading the value of a property
      // without validating that it exists.


      // The problem:

      // const user = { name: 'John' };
      // console.log(user.address.city); // TypeError: Cannot read property 'city' of undefined

      // One solution:

      // const user = { name: 'John' };
      // if (user.address) {
      //   console.log(user.address.city);
      // }
      // user.address = { city: 'New York' };
      // if (user.address) {
      //   console.log(user.address.city);
      // }


      // Better way to do it:

      // const user = { name: 'John' };
      // console.log(user.address?.city); // undefined
      // user.address = { city: 'New York' };
      // console.log(user.address?.city); // New York




      // CCL2 Example:
      // https://githubifc.iad.ca.inet/ContactCL/cbfq-rg-appstatic/blob/221f0651562dbd69730c14803696e3fa65b7dffe/projects/cbfq-appstatic/src/app/modules/automated-quote/components/automated-quote-in-progress-page/automated-quote-in-progress-page.component.ts#L250









      // We can use ?. with arrays


      // The problem:

      // const users = [ { name: 'John' }, { name: 'Jane' } ];
      // console.log(users[2].name); // TypeError: Cannot read property 'name' of undefined

      // The solution:

      // const users = [ { name: 'John' }, { name: 'Jane' } ];
      // console.log(users[2]?.name); // Output: undefined




      // CCL2 Example:
      // https://githubifc.iad.ca.inet/ContactCL/cbfq-rg-appstatic/blob/221f0651562dbd69730c14803696e3fa65b7dffe/projects/cbfq-appstatic/src/app/services/adobe-analytics.service.ts#L75









      // We can't use ?. on the left-hand
      // side of expression










      // let user = null;
      // user?.name = 'John';  // SyntaxError: Invalid left-hand side in assignment.






      // In this case we should
      // explicitly check existence of
      // the value with if condition












      // let user = null;
      //
      // if (user) {
      //   user.name = 'John';
      // } else {
      //   console.log('User is not defined');
      // }












      // Spread operator (...)












      // The spread operator (...) is a cool feature in JavaScript
      // that allows you to expand elements of an iterable
      // (like an array or object) into individual elements.
      // In other words "to copy" elements of an array or object.









      // Syntax:
      // [ ...array ]
      // { ...object }













      // Examples:



      // Copying arrays

      // I need to copy elements of the original array
      // into a new array.



      // One way - to loop over original array
      // and push each element into a new array

      // const originalArray = [1, 2, 3];
      // const copiedArray = [];
      // for (let i = 0; i < originalArray.length; i++) {
      //   copiedArray.push(originalArray[i]);
      // }
      // console.log(copiedArray); // [1, 2, 3]







      // Other way - to use .slice()

      // const originalArray = [1, 2, 3];
      // const copiedArray = originalArray.slice();
      // console.log(copiedArray); // [1, 2, 3]







      // With spread (...) operator:

      // const originalArray = [1, 2, 3];
      // const copiedArray = [ ...originalArray ];
      // console.log(copiedArray); //[1, 2, 3]















      // Merging arrays

      // const array1 = [1, 2, 3];
      // const array2 = ['a', 'b', 'c'];
      // console.log([ ...array1, ...array2 ]); // [1, 2, 3, 'a', 'b', 'c']




      // Copying objects

      // const originalObject = { name: 'John', age: 25 };
      // const duplicateObject = { ...originalObject };
      // console.log(duplicateObject); // { name: 'John', age: 25 }






      // Merging objects

      // const object1 = { a: 1, b: 2 };
      // const object2 = { c: 3, d: 4 };
      // const mergedObject = { ...object1, ...object2 };
      // console.log(mergedObject); // { a: 1, b: 2, c: 3, d: 4 }






      // We can do more cool staff with spread operator




      // Add elements to array

      // Example:

      // const array = [1, 2, 3];
      // const newArray = [0, ...array, 4];
      // console.log(newArray); // [0, 1, 2, 3, 4]







      // Pass arguments to a function

      // Example:

      // const sum = (a, b, c) => a + b + c;
      // const numbers = [1, 2, 3];
      // console.log(sum(numbers[0], numbers[1], numbers[2])); // 6
      // console.log(sum(...numbers)); // 6







      // What do you think will happen here?

      // const sum = (a, b, c) => a + b + c;
      // const numbers = [1, 2, 3, 4];
      // console.log(sum(...numbers)); // 6









      // And here?

      // const sum = (a, b, c) => a + b + c;
      // const numbers = [ 1 ];
      // console.log(sum(...numbers)); // NaN





      // We can pass more arguments than needed
      // to the function, but if we pass
      // less arguments, unexpected results can happen.










      // CCL2 Examples
      // https://githubifc.iad.ca.inet/ContactCL/cbfq-rg-appstatic/blob/be621c225d7cc0f1df688c64249d699cbae0dcff/projects/cbfq-appstatic/src/app/modules/credit-check/components/business-search-results/business-search-results.component.ts#L104
      // https://githubifc.iad.ca.inet/ContactCL/cbfq-rg-appstatic/blob/be621c225d7cc0f1df688c64249d699cbae0dcff/projects/cbfq-appstatic/src/app/modules/risk-exposure/components/entertainment/entertainment.component.ts#L339
















      // Object destructuring
















      // Object destructuring is a powerful feature in JavaScript.
      // It allows to extract properties from objects.
      // And assign them to variables.













      // Example

      // const person = { name: 'Alice', age: 25, city: 'Wonderland' };
      // const name = person.name;
      // const age = person.age;
      // const city = person.city;
      // console.log(name); // 'Alice'
      // console.log(age); // 25
      // console.log(city); // 'Wonderland'



      // Here I extracted values from the array and assigned
      // them to corresponding values.










      // I can do the same but in a concise way
      // with Object destructuring:



      // const person = { name: 'Alice', age: 25, city: 'Wonderland' };
      // const { name, age, city } = person;
      // console.log(name); // 'Alice'
      // console.log(age); // 25
      // console.log(city); // 'Wonderland'









      // I can give my variables other names while destructuring:

      // const person = { name: 'Alice', age: 25, city: 'Wonderland' };
      // const { name: personName, age: personAge } = person;
      // console.log(personName); // 'Alice'
      // console.log(personAge); // 25



      // This is essentially the same as:

      // const person = { name: 'Alice', age: 25, city: 'Wonderland' };
      // const personName = person.name;
      // const personAge = person.age;
      // console.log(personName); // 'Alice'
      // console.log(personAge); // 25






      // CCL2 Example:

      // https://githubifc.iad.ca.inet/ContactCL/cbfq-rg-appstatic/blob/6b5f74ee1aa18a168e7d18392d450a9d0e6e8b54/projects/cbfq-appstatic/src/app/modules/underwriter-questions/underwriter-questions.constants.ts#L3











      // I may wish not to extract all properties,
      // but only those which I need:

      // const person = { name: 'Alice', age: 25, city: 'Wonderland' };
      // const { age } = person;
      // console.log(age); // 25












      // I can set default values in case property doesn't exist

      // const person = { name: 'Alice', age: 25, city: 'Wonderland' };
      // const { age = 18, country = 'Unknown' } = person;
      // console.log(age); // 25
      // console.log(country); // 'Unknown'


      // Default property will be used only if value
      // is undefined.













      // const person = { name: 'Alice', age: null, city: 'Wonderland' };
      // const { age = 18 } = person;
      // console.log(age); // null


      // Default property is not used because the value
      // of 'age' property is not undefined.












      // We can use destructuring in
      // function parameters











      // const person = { name: 'Alice', age: 25, city: 'Wonderland' };
      //
      // function greet({ name, age }) {
      //     console.log(`Hello, ${name}! You are ${age} years old.`);
      // }
      //
      // greet(person); // 'Hello, Alice! You are 25 years old.'










      // You can't destructure null or undefined

      // const { name } = null; // TypeError: Cannot destructure property 'name' of 'null'







      // CCL2 Examples:
      // https://githubifc.iad.ca.inet/ContactCL/cbfq-rg-appstatic/blob/221f0651562dbd69730c14803696e3fa65b7dffe/projects/cbfq-appstatic/src/app/modules/bind/components/bind-payment-details/bind-payment-details.component.ts#L67
      // https://githubifc.iad.ca.inet/ContactCL/cbfq-rg-appstatic/blob/6b5f74ee1aa18a168e7d18392d450a9d0e6e8b54/projects/cbfq-appstatic/src/app/modules/underwriter-questions/components/questions-list/questions-list.component.ts#L6













      // Shorthand syntax to create objects







      // Regular way to create an object



      // const person = { income: '1000',  name: 'John' };
      // console.log(person); // { income: '1000',  name: 'John' }








      // Other way:

      // const income = '1000';
      // const name = 'John';
      // const person = { income: income, name: name };
      // console.log(person); // { income: '1000',  name: 'John' }







      // Shorthand notation

      // const income = '1000';
      // const name = 'John';
      // const person = { income, name };
      // console.log(person); // { income: '1000',  name: 'John' }



      // CCL2 Example:
      // https://githubifc.iad.ca.inet/ContactCL/cbfq-rg-appstatic/blob/6b5f74ee1aa18a168e7d18392d450a9d0e6e8b54/projects/cbfq-appstatic/src/app/modules/underwriter-questions/underwriter-questions.constants.ts#L15













      // ===










      // In JS, we check for strictly equal values using:
      // ===

      // Example of strict equality:
      // console.log(1 === 1); // true
      // console.log(1 === '1'); // false

      // The 2nd check is false because the number 1
      // does not strictly equal the string '1'.
      // Their types do not match. Number type
      // doesn't match String type.






      // Example of not strict equality:
      // console.log(1 == 1); // true
      // console.log(1 == '1'); // true

      // These both are true because JS
      // doesn't compare the types, only
      // the values. They both have the value 1.




      // This happens due to type coercion.

      // Example: 1 == '1'
      // 1) Type Coercion: JS sees that I am
      // comparing a number (1) and a string ('1').

      //
      // 2) Conversion:
      // JS tries to convert the string to a number
      // so that both values have the same type.
      // JS converts the string '1' to the number 1.
      //
      // 3) Comparison:
      // Now, both values are numbers: 1 == 1.
      // JS compares the values, and the evaluation is true.







      // More examples:
      // console.log(0 == false); // true (type coercion)
      // console.log(0 === false); // false (no type coercion)






      // Always use === to avoid unexpected type coercion.









      // Type coercion and + (plus)







      // In the case of the plus sign (+),
      // any time there is at least one string
      // involved, JS will try to concatenate
      // two strings instead of performing a math operation.







      // Examples:
      // console.log(1 + 1); // 2
      // console.log(1 + '1'); // '11'
      // console.log('1' + 1); // '11'
      // console.log('Hello' + 1); // 'Hello1'






      // If you want to explicitly convert
      // a string to a number, you can do either:
      // - Number('1')
      // - +'1'







      // Examples:
      // console.log(+'1' + 1); // 2
      // console.log(1 + +'1'); // 2
      // console.log(1 + Number('1')); // 2
















      // Sync vs Async














      // In JavaScript tasks can be handled in two ways:

      // -- Synchronously
      // -- Asynchronously (async)













      // Synchronous (Sync) means tasks happen one after another,
      // in the order they are written.

      // console.log("1");
      // console.log("2");
      // console.log("3");





      // Asynchronous (Async) means tasks can happen
      // at the same time, allowing the program to
      // keep running without waiting for each task to finish.

      // console.log("1");
      // setTimeout(() => console.log("2"));
      // console.log("3");


      // Async behavior can be produced by:
      // -- API calls
      // -- event listeners
      // -- timers










      // When we talk about asynchronous
      // we should mention two ways to handle it:

      // -- Promise (http calls)
      // -- Callbacks (event listeners)

















      // Promise

      // A Promise represents a value that will be available in the future.

      // A Promise is a result of asynchronous operation.
      // It can have two distinct states:

      // -- resolve
      // -- reject

      // .then() - in case promise resolves (returns data)
      // .catch() - in case promise is rejected (returns error)














      // API example

      // function getWeather() {
      //     console.log("Start");
      //     fetch('https://api.open-meteo.com/v1/forecast?latitude=52.52&longitude=13.41&hourly=temperature_2m')
      //         .then(response => console.log('Response', response.json()))
      //         .catch(error => console.log("Error:", error));
      //     console.log("Finish");
      // }
      //
      // getWeather();
















      // Important to remember!

      // Async is a fundamental part of the JavaScript.
      // You don’t explicitly code for async behavior.
      // You need to understand how async works.
      // But it still will work even
      // if you don't understand it ))













      // Why async is used?

      // We don’t want the program to freeze
      // while waiting for long tasks like
      // network requests or file reading.










      // To make async function behave like synchronous
      // we need to wait for its response using 'await'

      // async - add this keyword before function definition
      // await - add this keyword to async operation to wait for response










      // Adding 'async' keyword to a function
      // will make this function asynchronous
      // and this function will always return a Promise.














      // Example

      // Regular arrow function

      // const example = () => 5;
      // console.log(example());


      // Async function returning Promise

      // const example = async () => 5;
      // console.log(example());




      // Let's demonstrate the problem:

      // const example = () => 5; // add async
      // const result = example() + 1;
      // console.log(result);


      // To get actual result from async function

      // const example = async () => 5;
      // example().then(result => console.log(result));

      // Or if I need to use that value:

      // const example = async () => 5;
      // example().then(val => {
      //     const result = val + 1;
      //     console.log(result);
      // })














      // Let's make async to behave like sync

      // async function getWeather() {
      //     console.log("Start");
      //     const result = await fetch('https://api.open-meteo.com/v1/forecast?latitude=52.52&longitude=13.41&hourly=temperature_2m')
      //         .then(response => response.json())
      //         .catch(error => console.log("Error:", error));
      //     console.log(result);
      //     console.log("Finish");
      // }
      //
      // getWeather();




















      // Callback

      // A special function attached to event
      // when we listen to this event.











      // Example of Callback

      // document.querySelector('button').addEventListener('click', function () {
      //     console.log('Button was clicked!');
      // });

      // Callback is:

      // function () {
      //    console.log('Button was clicked!');
      // }


      // We wait for event to happen to execute our code.
      // Our program continues to run without waiting
      // for button click to occur.










      // Callback can have a name:

      // const handleClick = () => console.log('Click event happened');
      // document.querySelector('button').addEventListener('click', handleClick);
























      // Thank you!


















    }


  </script>
</head>
<body>

</body>
</html>